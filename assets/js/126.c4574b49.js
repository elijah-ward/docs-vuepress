(window.webpackJsonp=window.webpackJsonp||[]).push([[126],{610:function(e,t,o){"use strict";o.r(t);var r=o(0),a=Object(r.a)({},function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"orchestrator-plugin"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#orchestrator-plugin","aria-hidden":"true"}},[e._v("#")]),e._v(" Orchestrator Plugin")]),e._v(" "),o("p",[e._v("Updated April 10, 2015")]),e._v(" "),o("h2",{attrs:{id:"configuring"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#configuring","aria-hidden":"true"}},[e._v("#")]),e._v(" Configuring")]),e._v(" "),o("p",[e._v("Orchestrators are configured in a Job definition, see: [Jobs - Orchestrator](/manual/creating-jobs.md#orchestrator].")]),e._v(" "),o("h2",{attrs:{id:"java-plugin-type"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#java-plugin-type","aria-hidden":"true"}},[e._v("#")]),e._v(" Java Plugin Type")]),e._v(" "),o("ul",[o("li",[o("em",[e._v("Note")]),e._v(": Refer to [Java Development](/developer/01-plugin-development.md#java-plugin-development] for information about developing a Java plugin for Rundeck.")])]),e._v(" "),o("p",[e._v("The plugin interface is "),o("router-link",{attrs:{to:"/developer/${javadocbase}/com/dtolabs/rundeck/plugins/orchestrator/OrchestratorPlugin.html"}},[e._v("OrchestratorPlugin")]),e._v(".")],1),e._v(" "),o("p",[e._v("This is actually a Factory pattern, which produces an "),o("router-link",{attrs:{to:"/developer/${javadocbase}/com/dtolabs/rundeck/plugins/orchestrator/Orchestrator.html"}},[e._v("Orchestrator")]),e._v(" instance.")],1),e._v(" "),o("p",[e._v("The "),o("code",[e._v("Orchestrator")]),e._v(" instance is responsible for determining what order and how many nodes are available to execute on.")]),e._v(" "),o("p",[e._v("All of the methods on the orchestrator will be called on the same thread,\nso your Orchestrator implementation does not need to worry about synchronization.")]),e._v(" "),o("p",[e._v("The "),o("code",[e._v("getNode()")]),e._v(" method will be called multiple times to retrieve any available Nodes for processing.\nIf it returns "),o("code",[e._v("null")]),e._v(", that indicates no nodes are currently available.\n"),o("code",[e._v("isComplete")]),e._v(" method will be called to determine if any nodes will be available in the future if "),o("code",[e._v("null")]),e._v(" has been returned.\nNote that "),o("code",[e._v("isComplete")]),e._v(" does not need to wait for all nodes to be returned via "),o("code",[e._v("returnNode")]),e._v(",\nit merely has to indicate if any new nodes will be returned from "),o("code",[e._v("getNode()")]),e._v(".")]),e._v(" "),o("p",[e._v("The Orchestrator should return a node from getNode when it is ready to be executed on.\nOnce the execution is completed on a node the "),o("code",[e._v("returnNode(OrchestratorNodeResult)")]),e._v(" method will be called with the node and information about the success status of the execution,\nallowing the Orchestrator to mark new nodes to be released.")]),e._v(" "),o("p",[e._v("Nodes may be executed on in the same or on multiple threads,\nthe Orchestrator processor will manage the threads based on the configured Threadcount for the job.")]),e._v(" "),o("p",[e._v("In this manner, the Orchestrator allows some number of nodes to be executed on simultaneously, and manages\nwhen new nodes are available.")]),e._v(" "),o("p",[e._v("Note: The Orchestrator must abide by these limitations:")]),e._v(" "),o("ol",[o("li",[e._v("A node may not be processed more than once, so getNode should always return a new node, or null.")]),e._v(" "),o("li",[e._v("The Orchestrator must return nodes from the original set given to the OrchestratorPlugin, it cannot introduce new nodes")])])])},[],!1,null,null,null);t.default=a.exports}}]);